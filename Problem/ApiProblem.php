<?php

/*
 * This file is part of the FOSRestBundle package.
 *
 * (c) FriendsOfSymfony <http://friendsofsymfony.github.com/>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace FOS\Restbundle\Problem;

use Symfony\Component\HttpFoundation\Response;

/**
 * @link   http://tools.ietf.org/html/rfc7807
 *
 * @author Alexandru Furculita <alex@furculita.net>
 */
class ApiProblem
{
    private static $acceptedFormats = [
        'json' => 'application/problem+json',
        'xml'  => 'application/problem+xml',
    ];

    /**
     * A URI reference that identifies the problem type.
     *
     * RFC 7807 encourages that, when dereferenced, it provide
     * human-readable documentation for the problem type (e.g.,
     * using HTML). When this member is not present, its value
     * is assumed to be "about:blank".
     *
     * Consumers MUST use the "type" string as the primary identifier for the
     * problem type.
     *
     * This value may be an absolute or or relative URI. If relative, it MUST be
     * resolved relative to the document's base URI, as per RFC3986, Section 5.
     *
     * @link http://tools.ietf.org/html/rfc3986
     *
     * @var string
     */
    protected $type = 'about:blank';

    /**
     * A short, human-readable summary of the problem type.
     *
     * It SHOULD NOT change from occurrence to occurrence of the
     * problem, except for purposes of localization (e.g., using
     * proactive content negotiation).
     *
     * @var string
     */
    protected $title;

    /**
     * The HTTP status code generated by the origin server for this
     * occurrence of the problem.
     *
     * The status member, if present, is only advisory; it conveys the HTTP
     * status code used for the convenience of the consumer. Generators MUST
     * use the same status code in the actual HTTP response, to assure that
     * generic HTTP software that does not understand this format still behaves
     * correctly.
     *
     * @var int
     */
    protected $status;

    /**
     * A human-readable explanation specific to this occurrence of
     * the problem.
     *
     * The "detail" member, if present, ought to focus on helping the client
     * correct the problem, rather than giving debugging information.
     *
     * Consumers SHOULD NOT parse the "detail" member for information; extensions
     * are more suitable and less error-prone ways to obtain such information.
     *
     * @var string
     */
    protected $detail = '';

    /**
     * A URI reference that identifies the specific occurrence of the problem.
     *
     * It may or may not yield further information if dereferenced.
     *
     * This value may be an absolute or or relative URI. If relative, it MUST be
     * resolved relative to the document's base URI, as per RFC3986, Section 5.
     *
     * @link http://tools.ietf.org/html/rfc3986
     *
     * @var string
     */
    protected $instance;

    /**
     * An array with additional properties that extend the problem details object.
     *
     * Clients consuming problem details MUST ignore any such extensions
     * that they don't recognize; this allows problem types to evolve and
     * include additional information in the future.
     *
     * Note that because extensions are effectively put into a namespace by
     * the problem type, it is not possible to define new "standard" members
     * without defining a new media type.
     *
     * @var array
     */
    protected $extensions = [];

    /**
     * Creates a new ApiProblem using the provided information.
     *
     * If nothing is provided for the type field, the class default will be used.
     * If the status matches any known, the title field will be selected
     * from $problemStatusTitles as a result.
     *
     * @param int    $status
     * @param string $detail
     * @param string $type
     * @param string $instance
     * @param string $title
     * @param array  $extensions
     *
     * @throws \InvalidArgumentException If the status code is invalid.
     */
    public function __construct($status, $detail, $type = null, $instance = null, $title = null, array $extensions = [])
    {
        $this->status = $status;

        if ($this->status < 100 || $this->status >= 600) {
            throw new \InvalidArgumentException(sprintf('The HTTP status code "%s" is not valid.', $this->status));
        }

        $this->title = $title;
        if (null === $this->title && array_key_exists($status, Response::$statusTexts)) {
            $this->title = Response::$statusTexts[$status];
        }

        $this->instance   = $instance;
        $this->detail     = $detail;
        $this->extensions = $extensions;

        if (null !== $type) {
            $this->type = $type;
        }
    }

    /**
     * Transforms an array into an ApiProblem object.
     *
     * @param array $details
     *
     * @return static
     */
    public static function create(array $details)
    {
        $arr = ['title' => null, 'type' => null, 'status' => null, 'detail' => null, 'instance' => null];

        $details = array_merge($arr, $details);

        $filter = function ($key) use ($arr) {
            return !array_key_exists($key, $arr);
        };

        return new static(
            $details['status'],
            $details['details'],
            $details['type'],
            $details['instance'],
            $details['title'],
            array_filter($details, $filter)
        );
    }

    /**
     * Cast to an array
     *
     * @return array
     */
    public function toArray()
    {
        return array_merge(
            $this->extensions,
            [
                'type'     => $this->type,
                'title'    => $this->getTitle(),
                'status'   => $this->getStatus(),
                'detail'   => $this->getDetail(),
                'instance' => $this->getInstance(),
            ]
        );
    }

    /**
     * Retrieve the Api Problem title.
     *
     * @return string
     */
    public function getTitle()
    {
        return $this->title ?: 'Unknown';
    }

    /**
     * Retrieve the Api Problem HTTP status code.
     *
     * @return int
     */
    public function getStatus()
    {
        return $this->status;
    }

    /**
     * Retrieve the Api Problem detail.
     *
     * @return string
     */
    public function getDetail()
    {
        return $this->detail;
    }

    /**
     * Retrieve the Api Problem instance URI.
     *
     * @return string
     */
    public function getInstance()
    {
        return $this->instance;
    }

    /**
     * Check if the given format is an accepted format to be used for an API problem.
     *
     * @param string $format
     *
     * @return bool
     */
    public static function isAcceptedFormat($format)
    {
        return array_key_exists($format, static::$acceptedFormats);
    }

    /**
     * Return the media type for a given format.
     *
     * @param string $format
     *
     * @return string
     */
    public static function getMediaType($format)
    {
        if (!static::isAcceptedFormat($format)) {
            throw new \InvalidArgumentException(sprintf('The format "%s" is not supported for API problems', $format));
        }

        return static::$acceptedFormats[$format];
    }
}
